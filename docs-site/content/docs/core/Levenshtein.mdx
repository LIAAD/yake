
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion'

# Levenshtein

The `Levenshtein` class provides utilities for calculating edit distances and similarity ratios between strings using the Levenshtein algorithm.

> **Info:** This documentation provides interactive code views for each method. Click on a function name to view its implementation.

## Class Overview

```python
class Levenshtein:
    """Class for computing Levenshtein distance and similarity ratio."""
```

The `Levenshtein` class offers methods to measure the difference between two strings and calculate their similarity.

## Static Methods

<Accordion type="single" collapsible>
  <AccordionItem value="ratio-private">
    <AccordionTrigger>
      <code>__ratio(distance, str_length)</code>
    </AccordionTrigger>
    <AccordionContent>
      ```python
      @staticmethod
      def __ratio(distance: float, str_length: int) -> float:
          """Calculate the similarity ratio based on distance and string length.

          Args:
              distance (float): The Levenshtein distance between two strings.
              str_length (int): The length of the longer string.

          Returns:
              float: The similarity ratio.
          """
          return 1 - float(distance) / float(str_length)
      ```
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="ratio">
    <AccordionTrigger>
      <code>ratio(seq1, seq2)</code>
    </AccordionTrigger>
    <AccordionContent>
      ```python
      @staticmethod
      def ratio(seq1: str, seq2: str) -> float:
          """Compute the similarity ratio between two strings.

          Args:
              seq1 (str): The first string.
              seq2 (str): The second string.

          Returns:
              float: The similarity ratio.
          """
          str_distance = Levenshtein.distance(seq1, seq2)
          str_length = max(len(seq1), len(seq2))
          return Levenshtein.__ratio(str_distance, str_length)
      ```
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="distance">
    <AccordionTrigger>
      <code>distance(seq1, seq2)</code>
    </AccordionTrigger>
    <AccordionContent>
      ```python
      @staticmethod
      def distance(seq1: str, seq2: str) -> int:
          """Calculate the Levenshtein distance between two strings.

          Args:
              seq1 (str): The first string.
              seq2 (str): The second string.

          Returns:
              int: The Levenshtein distance.
          """
          size_x = len(seq1) + 1
          size_y = len(seq2) + 1
          matrix = np.zeros((size_x, size_y))

          for x in range(size_x):
              matrix[x, 0] = x
          for y in range(size_y):
              matrix[0, y] = y

          for x in range(1, size_x):
              for y in range(1, size_y):
                  if seq1[x - 1] == seq2[y - 1]:
                      cost = 0
                  else:
                      cost = 1

                  matrix[x, y] = min(
                      matrix[x - 1, y] + 1,  # Deletion
                      matrix[x, y - 1] + 1,  # Insertion
                      matrix[x - 1, y - 1] + cost,  # Substitution
                  )

          return int(matrix[size_x - 1, size_y - 1])
      ```
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Usage Guide

### Distance Calculation

The Levenshtein distance measures the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into another.

**Example:**
```python
from levenshtein import Levenshtein

# Calculate the edit distance between two strings
distance = Levenshtein.distance("kitten", "sitting")
print(f"Levenshtein distance: {distance}")  # Output: 3
```

### Similarity Ratio

The similarity ratio is a normalized measure between 0 and 1, where 1 means the strings are identical and 0 means they are completely different.

**Example:**
```python
from levenshtein import Levenshtein

# Calculate the similarity ratio between two strings
similarity = Levenshtein.ratio("kitten", "sitting")
print(f"Similarity ratio: {similarity:.4f}")  # Output: 0.5714
```

## Algorithm Explanation

The Levenshtein distance algorithm uses dynamic programming to calculate the minimum edit distance between two strings:

1. Initialize a matrix of size `(len(seq1)+1) × (len(seq2)+1)`
2. Fill the first row and column with increasing integers (0, 1, 2, ...)
3. For each cell in the matrix:
   - If the corresponding characters match, the cost is 0; otherwise, it's 1
   - Calculate the minimum cost from three possible operations:
     - Deletion: Value from the cell above + 1
     - Insertion: Value from the cell to the left + 1
     - Substitution: Value from the diagonal cell + cost
4. The bottom-right cell contains the final Levenshtein distance

## Complete Usage Example

```python
import numpy as np
from levenshtein import Levenshtein

# Test strings
string1 = "natural language processing"
string2 = "neural language processing"

# Calculate distance and similarity
distance = Levenshtein.distance(string1, string2)
similarity = Levenshtein.ratio(string1, string2)

print(f"Strings:\n1: '{string1}'\n2: '{string2}'")
print(f"Levenshtein distance: {distance}")
print(f"Similarity ratio: {similarity:.4f}")

# Example output:
# Strings:
# 1: 'natural language processing'
# 2: 'neural language processing'
# Levenshtein distance: 3
# Similarity ratio: 0.8889
```

## Performance Considerations

- Time Complexity: O(m×n) where m and n are the lengths of the input strings
- Space Complexity: O(m×n) due to the matrix storage
- For very long strings, consider using optimized variants or approximate algorithms

## Dependencies

The `Levenshtein` class relies on:

- `numpy`: For efficient matrix operations
